Method,Comment
public int hashCode ( ) { return value . hashCode ( ) ; },this returns the hash code for the key . the hash code is generated from the internal string the key represents .
public void onStart ( ) { },"fired when the request is started , override to handle in your own code"
@ Override protected void propertyChange ( PropertyChangeEvent evt ) { if ( SeaGlassLookAndFeel . shouldUpdateStyle ( evt ) ) { updateStyle ( ( JTextComponent ) evt . getSource ( ) ) ; } super . propertyChange ( evt ) ; },this method gets called when a bound property is changed on the associated jtextcomponent . this is a hook which ui implementations may change to reflect how the ui displays bound properties of jtextcomponent subclasses . this is implemented to rebuild the actionmap based upon an editorkit change .
"@ NotNull public PsiQuery filter ( @ NotNull final Class < ? extends PsiNamedElement > clazz , @ NotNull final String name ) { final Set < PsiElement > result = new HashSet < PsiElement > ( Arrays . asList ( myPsiElements ) ) ; for ( final PsiElement element : myPsiElements ) { final PsiNamedElement namedElement = PyUtil . as ( element , clazz ) ; if ( ( namedElement == null ) || ( ! name . equals ( namedElement . getName ( ) ) ) ) { result . remove ( element ) ; } } return new PsiQuery ( result . toArray ( new PsiElement [ result . size ( ) ] ) ) ; }",filter elements by class and name
"protected void writeQualifiedName ( String nsAlias , String name ) throws IOException { if ( nsAlias != null && nsAlias . length ( ) > _NUM ) { writer . write ( nsAlias ) ; writer . write ( STRING ) ; } writer . write ( name ) ; }",writes a namespace qualified element or attribute name .
"public TextEditor deleteAll ( String pattern ) { return replaceAll ( pattern , STRING ) ; }","remove all occurrences of the given regex pattern , replacing them with the empty string ."
"public synchronized GcmHelper addRegistrationCallback ( @ NonNull Context context , @ NonNull GcmRegistrationListener registrationListener , boolean sticky ) { if ( null == registrationCallbacks ) { registrationCallbacks = new ConcurrentLinkedQueue < > ( ) ; } registrationCallbacks . add ( registrationListener ) ; if ( sticky && ! TextUtils . isEmpty ( this . pushToken ) ) { registrationListener . onTokenAvailable ( context , pushToken , _BOOL ) ; } return this ; }",add a gcm registration listener . this does not replace the existing listeners but adds to the list of listeners
"@ Override public void acceptTrainingSet ( TrainingSetEvent e ) { Instances trainingSet = e . getTrainingSet ( ) ; DataSetEvent dse = new DataSetEvent ( this , trainingSet ) ; acceptDataSet ( dse ) ; }",accept a training set
"< T > List < T > onFind ( Class < T > modelClass , String [ ] columns , String [ ] conditions , String orderBy , String limit , boolean isEager ) { BaseUtility . checkConditionsCorrect ( conditions ) ; List < T > dataList = query ( modelClass , columns , getWhereClause ( conditions ) , getWhereArgs ( conditions ) , null , null , orderBy , limit , getForeignKeyAssociations ( modelClass . getName ( ) , isEager ) ) ; return dataList ; }",the open interface for other classes in crud package to query multiple records by parameters .
private boolean isAgentEmpty ( Agent agent ) { if ( agent != null ) { String first = agent . getFirstName ( ) ; String last = agent . getLastName ( ) ; String email = agent . getEmail ( ) ; String home = agent . getHomepage ( ) ; String org = agent . getOrganisation ( ) ; String phone = agent . getPhone ( ) ; String position = agent . getPosition ( ) ; String city = null ; String street = null ; String country = null ; String code = null ; String province = null ; Address address = agent . getAddress ( ) ; if ( address != null ) { city = address . getCity ( ) ; street = address . getAddress ( ) ; country = address . getCountry ( ) ; code = address . getPostalCode ( ) ; province = address . getProvince ( ) ; } String directory = null ; String identifier = null ; List < UserId > userIds = agent . getUserIds ( ) ; if ( ! userIds . isEmpty ( ) ) { UserId userId = userIds . get ( _NUM ) ; directory = userId . getDirectory ( ) ; identifier = userId . getIdentifier ( ) ; } return ( Strings . isNullOrEmpty ( city ) && Strings . isNullOrEmpty ( street ) && Strings . isNullOrEmpty ( country ) && Strings . isNullOrEmpty ( code ) && Strings . isNullOrEmpty ( province ) && Strings . isNullOrEmpty ( first ) && Strings . isNullOrEmpty ( last ) && Strings . isNullOrEmpty ( email ) && Strings . isNullOrEmpty ( home ) && Strings . isNullOrEmpty ( org ) && Strings . isNullOrEmpty ( phone ) && Strings . isNullOrEmpty ( position ) && Strings . isNullOrEmpty ( directory ) && Strings . isNullOrEmpty ( identifier ) ) ; } return _BOOL ; },"determine if the agent is empty . in other words , the user hasn ' t entered any information for a single field yet ."
"public static byte [ ] calendarToRawBytes ( Calendar timestamp , boolean honorDeviceTimeOffset ) { if ( honorDeviceTimeOffset ) { int offsetInHours = MiBandCoordinator . getDeviceTimeOffsetHours ( ) ; if ( offsetInHours != _NUM ) { timestamp . add ( Calendar . HOUR_OF_DAY , offsetInHours ) ; } } byte [ ] year = fromUint16 ( timestamp . get ( Calendar . YEAR ) ) ; return new byte [ ] { year [ _NUM ] , year [ _NUM ] , fromUint8 ( timestamp . get ( Calendar . MONTH ) + _NUM ) , fromUint8 ( timestamp . get ( Calendar . DATE ) ) , fromUint8 ( timestamp . get ( Calendar . HOUR_OF_DAY ) ) , fromUint8 ( timestamp . get ( Calendar . MINUTE ) ) , fromUint8 ( timestamp . get ( Calendar . SECOND ) ) , dayOfWeekToRawBytes ( timestamp ) , _NUM } ; }",converts a timestamp to the byte sequence to be sent to the current time characteristic
"private static void decodeBase256Segment ( BitSource bits , StringBuilder result , Collection < byte [ ] > byteSegments ) throws FormatException { int codewordPosition = _NUM + bits . getByteOffset ( ) ; int d1 = unrandomize255State ( bits . readBits ( _NUM ) , codewordPosition ++ ) ; int count ; if ( d1 == _NUM ) { count = bits . available ( ) / _NUM ; } else if ( d1 < _NUM ) { count = d1 ; } else { count = _NUM * ( d1 - _NUM ) + unrandomize255State ( bits . readBits ( _NUM ) , codewordPosition ++ ) ; } if ( count < _NUM ) { throw FormatException . getFormatInstance ( ) ; } byte [ ] bytes = new byte [ count ] ; for ( int i = _NUM ; i < count ; i ++ ) { if ( bits . available ( ) < _NUM ) { throw FormatException . getFormatInstance ( ) ; } bytes [ i ] = ( byte ) unrandomize255State ( bits . readBits ( _NUM ) , codewordPosition ++ ) ; } byteSegments . add ( bytes ) ; try { result . append ( new String ( bytes , STRING ) ) ; } catch ( UnsupportedEncodingException uee ) { throw new IllegalStateException ( STRING + uee ) ; } }","see iso 16022 : 2006 , 5 . 2 . 9 and annex b , b . 2"
"protected void initBPOrderDetails ( int C_BPartner_ID , boolean forInvoice ) { log . config ( STRING + C_BPartner_ID ) ; KeyNamePair pp = new KeyNamePair ( _NUM , STRING ) ; orderField . removeActionListener ( this ) ; orderField . removeAllItems ( ) ; orderField . addItem ( pp ) ; ArrayList < KeyNamePair > list = loadOrderData ( C_BPartner_ID , forInvoice , sameWarehouseCb . isSelected ( ) ) ; for ( KeyNamePair knp : list ) orderField . addItem ( knp ) ; orderField . setSelectedIndex ( _NUM ) ; orderField . addActionListener ( this ) ; initBPDetails ( C_BPartner_ID ) ; }",load pbartner dependent order / invoice / shipment field .
"public ModpackInitializationPanel ( WizardController controller , Map wizardData , Vector < String > versions , String selVersion ) { initComponents ( ) ; this . controller = controller ; this . wizardData = wizardData ; wizardData . put ( KEY_GAME_VERSION , versions ) ; wizardData . put ( STRING , selVersion ) ; wizardData . put ( KEY_INCLUDING_LAUNCHER , _BOOL ) ; configureComboContents ( ) ; checkProblem ( ) ; }",creates new form modpackinitializationpanel
public synchronized void remove ( int index ) { super . remove ( index ) ; double removedValue = mValue . remove ( index ) ; if ( removedValue == mMinValue || removedValue == mMaxValue ) { initRange ( ) ; } },removes an existing value from the series .
private boolean coordIsCalendarCell ( float y ) { return y > cellHeight ; },"y is bigger than the head of the calendar , meaning that the coordination may represent a day of the calendar"
protected void sprint ( double doubleField ) { sprint ( String . valueOf ( doubleField ) ) ; },pretty printing accumulator function for doubles
private int attributeMap ( String name ) { Integer num = map . get ( name ) ; if ( num == null ) { return _NUM ; } return num . intValue ( ) ; },returns the integer attribute number for the passed attribute name .